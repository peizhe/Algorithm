package Algorithm;
/**
 * 
 * @author MG
 *
 */
public class LRUAndFIFOAndLFU {
	
	/**
	 * Least recently used，最近最少使用(其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。)
	 * 	原理：
	 * 	1. 新数据插入到链表头部；
	 *  2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
	 *  3. 当链表满的时候，将链表尾部的数据丢弃。
	 * 
	 * 
	 * 一般选择题会让计算缺页次数
	 */
	public static class LRU{
		
	}
	
	/**
	 * FIFO(First in First out),先进先出(核心原则就是：如果一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。)
	 * 	原理：
	 * 	1.新数据插入链表头部
	 *  2.当链表满的时候，将链表尾部的数据丢去
	 * 
	 * 实现：
	 * 	利用一个双向链表保存数据，当来了新的数据之后便添加到链表末尾，如果Cache存满数据，则把链表头部数据删除，然后把新的数据添加到链表末尾。
	 * 	在访问数据的时候，如果在Cache中存在该数据的话，则返回对应的value值；否则返回-1。如果想提高访问效率，可以利用hashmap来保存每个key在链表中对应的位置。
	 * @author MG
	 *
	 */
	public static class FIFO{
		
	}
	
	/**
	 * 不经常用
	 * LFU(Least Frequently Used),最近最少使用算法。(核心原则是：如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小”的思路。)
	 * 	原理：
	 * 	1.新数据插入链表头部
	 * 	2.当链表满的时候，将链表中访问次数最少的那个删除掉
	 * 
	 * 实现：
	 * 	map实现
	 * @author MG
	 *
	 */
	public static class LFU{
		
	}
}
